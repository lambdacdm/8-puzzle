# 8-puzzle 问题介绍
举个例子，将如下数字拼图
|7|5|4|
|--|--|--|
|2|3| |
|8|6|1|

只通过有限次挪动数字，变换到最终局面
|1|2|3|
|--|--|--|
|4|5|6|
|7|8| |

一般地，我们有：

输入：一个3*3的盘面

输出：变换到最终局面所需的最少步数，以及每一步的解法
# 开发
本程序使用C++语言，标准是C++14，所用编译器是gcc 10.1.1
# A<sup>*</sup>算法
该程序使用A<sup>*</sup>算法。这是一种启发式算法，并且能够保证寻得最优解。具体而言，

f(n)=h(n)+g(n)

其中g(n)是代价函数，定义为当前路径的长度。

h(n)是估价函数，定义为各个数字假设在无干扰条件下移到最终位置的最短步数之和。

由于h(n)恒大于等于实际的最少步数，因此这是一个A<sup>*</sup>算法，即一定能保证最短步骤移动到最终局面。

实现A<sup>*</sup>算法的数据结构是优先队列。
# 全排列与Cantor展开
8-puzzle的盘面本质上是1-9的全排列（空格记为9）。因此可以用全排列来表示盘面。在本程序中，
用长度为9的字符串来表示全排列（即表示盘面）。

搜索时的难点是判断当前节点在之前是否已经访问过。为了解决这个问题，可以开辟一个长度为
9!=362880的数组visited，每个位置的值是0或1，用以表示每个排列是否在之前已访问过。

不过一个困难是，需要访问visited数组的索引，这就要建立从全排列到自然数之间的双射。
使用Cantor展开，可以实现这一点。
